Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> VAR vdeclarations BEGIN commands END
Rule 2     vdeclarations -> vdeclarations PIDENTIFIER
Rule 3     vdeclarations -> vdeclarations PIDENTIFIER LBRACKET NUMBER RBRACKET
Rule 4     vdeclarations -> empty
Rule 5     commands -> commands command
Rule 6     commands -> command
Rule 7     command -> identifier ASSIGN expression SEMICOLON
Rule 8     command -> IF condition THEN commands ELSE commands ENDIF
Rule 9     command -> IF condition THEN commands ENDIF
Rule 10    command -> WHILE condition DO commands ENDWHILE
Rule 11    command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
Rule 12    command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
Rule 13    command -> READ identifier SEMICOLON
Rule 14    command -> WRITE value SEMICOLON
Rule 15    expression -> value
Rule 16    expression -> value PLUS value
Rule 17    expression -> value MINUS value
Rule 18    expression -> value TIMES value
Rule 19    expression -> value DIVIDE value
Rule 20    expression -> value MODULO value
Rule 21    condition -> value EQ value
Rule 22    condition -> value NE value
Rule 23    condition -> value LT value
Rule 24    condition -> value GT value
Rule 25    condition -> value LE value
Rule 26    condition -> value GE value
Rule 27    value -> NUMBER
Rule 28    value -> identifier
Rule 29    identifier -> PIDENTIFIER
Rule 30    identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
Rule 31    identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET
Rule 32    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 7
BEGIN                : 1
DIVIDE               : 19
DO                   : 10 11 12
DOWNTO               : 12
ELSE                 : 8
END                  : 1
ENDFOR               : 11 12
ENDIF                : 8 9
ENDWHILE             : 10
EQ                   : 21
FOR                  : 11 12
FROM                 : 11 12
GE                   : 26
GT                   : 24
IF                   : 8 9
LBRACKET             : 3 30 31
LE                   : 25
LT                   : 23
MINUS                : 17
MODULO               : 20
NE                   : 22
NUMBER               : 3 27 31
PIDENTIFIER          : 2 3 11 12 29 30 30 31
PLUS                 : 16
RBRACKET             : 3 30 31
READ                 : 13
SEMICOLON            : 7 13 14
THEN                 : 8 9
TIMES                : 18
TO                   : 11
VAR                  : 1
WHILE                : 10
WRITE                : 14
error                : 

Nonterminals, with rules where they appear

command              : 5 6
commands             : 1 5 8 8 9 10 11 12
condition            : 8 9 10
empty                : 4
expression           : 7
identifier           : 7 13 28
program              : 0
value                : 11 11 12 12 14 15 16 16 17 17 18 18 19 19 20 20 21 21 22 22 23 23 24 24 25 25 26 26
vdeclarations        : 1 2 3

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . VAR vdeclarations BEGIN commands END

    VAR             shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> VAR . vdeclarations BEGIN commands END
    (2) vdeclarations -> . vdeclarations PIDENTIFIER
    (3) vdeclarations -> . vdeclarations PIDENTIFIER LBRACKET NUMBER RBRACKET
    (4) vdeclarations -> . empty
    (32) empty -> .

    BEGIN           reduce using rule 32 (empty -> .)
    PIDENTIFIER     reduce using rule 32 (empty -> .)

    vdeclarations                  shift and go to state 3
    empty                          shift and go to state 4

state 3

    (1) program -> VAR vdeclarations . BEGIN commands END
    (2) vdeclarations -> vdeclarations . PIDENTIFIER
    (3) vdeclarations -> vdeclarations . PIDENTIFIER LBRACKET NUMBER RBRACKET

    BEGIN           shift and go to state 5
    PIDENTIFIER     shift and go to state 6


state 4

    (4) vdeclarations -> empty .

    BEGIN           reduce using rule 4 (vdeclarations -> empty .)
    PIDENTIFIER     reduce using rule 4 (vdeclarations -> empty .)


state 5

    (1) program -> VAR vdeclarations BEGIN . commands END
    (5) commands -> . commands command
    (6) commands -> . command
    (7) command -> . identifier ASSIGN expression SEMICOLON
    (8) command -> . IF condition THEN commands ELSE commands ENDIF
    (9) command -> . IF condition THEN commands ENDIF
    (10) command -> . WHILE condition DO commands ENDWHILE
    (11) command -> . FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> . FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
    (13) command -> . READ identifier SEMICOLON
    (14) command -> . WRITE value SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    READ            shift and go to state 14
    WRITE           shift and go to state 15
    PIDENTIFIER     shift and go to state 13

    commands                       shift and go to state 7
    command                        shift and go to state 8
    identifier                     shift and go to state 9

state 6

    (2) vdeclarations -> vdeclarations PIDENTIFIER .
    (3) vdeclarations -> vdeclarations PIDENTIFIER . LBRACKET NUMBER RBRACKET

    BEGIN           reduce using rule 2 (vdeclarations -> vdeclarations PIDENTIFIER .)
    PIDENTIFIER     reduce using rule 2 (vdeclarations -> vdeclarations PIDENTIFIER .)
    LBRACKET        shift and go to state 16


state 7

    (1) program -> VAR vdeclarations BEGIN commands . END
    (5) commands -> commands . command
    (7) command -> . identifier ASSIGN expression SEMICOLON
    (8) command -> . IF condition THEN commands ELSE commands ENDIF
    (9) command -> . IF condition THEN commands ENDIF
    (10) command -> . WHILE condition DO commands ENDWHILE
    (11) command -> . FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> . FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
    (13) command -> . READ identifier SEMICOLON
    (14) command -> . WRITE value SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    END             shift and go to state 17
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    READ            shift and go to state 14
    WRITE           shift and go to state 15
    PIDENTIFIER     shift and go to state 13

    command                        shift and go to state 18
    identifier                     shift and go to state 9

state 8

    (6) commands -> command .

    END             reduce using rule 6 (commands -> command .)
    IF              reduce using rule 6 (commands -> command .)
    WHILE           reduce using rule 6 (commands -> command .)
    FOR             reduce using rule 6 (commands -> command .)
    READ            reduce using rule 6 (commands -> command .)
    WRITE           reduce using rule 6 (commands -> command .)
    PIDENTIFIER     reduce using rule 6 (commands -> command .)
    ELSE            reduce using rule 6 (commands -> command .)
    ENDIF           reduce using rule 6 (commands -> command .)
    ENDWHILE        reduce using rule 6 (commands -> command .)
    ENDFOR          reduce using rule 6 (commands -> command .)


state 9

    (7) command -> identifier . ASSIGN expression SEMICOLON

    ASSIGN          shift and go to state 19


state 10

    (8) command -> IF . condition THEN commands ELSE commands ENDIF
    (9) command -> IF . condition THEN commands ENDIF
    (21) condition -> . value EQ value
    (22) condition -> . value NE value
    (23) condition -> . value LT value
    (24) condition -> . value GT value
    (25) condition -> . value LE value
    (26) condition -> . value GE value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    condition                      shift and go to state 20
    value                          shift and go to state 21
    identifier                     shift and go to state 23

state 11

    (10) command -> WHILE . condition DO commands ENDWHILE
    (21) condition -> . value EQ value
    (22) condition -> . value NE value
    (23) condition -> . value LT value
    (24) condition -> . value GT value
    (25) condition -> . value LE value
    (26) condition -> . value GE value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    condition                      shift and go to state 24
    value                          shift and go to state 21
    identifier                     shift and go to state 23

state 12

    (11) command -> FOR . PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> FOR . PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR

    PIDENTIFIER     shift and go to state 25


state 13

    (29) identifier -> PIDENTIFIER .
    (30) identifier -> PIDENTIFIER . LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> PIDENTIFIER . LBRACKET NUMBER RBRACKET

    ASSIGN          reduce using rule 29 (identifier -> PIDENTIFIER .)
    EQ              reduce using rule 29 (identifier -> PIDENTIFIER .)
    NE              reduce using rule 29 (identifier -> PIDENTIFIER .)
    LT              reduce using rule 29 (identifier -> PIDENTIFIER .)
    GT              reduce using rule 29 (identifier -> PIDENTIFIER .)
    LE              reduce using rule 29 (identifier -> PIDENTIFIER .)
    GE              reduce using rule 29 (identifier -> PIDENTIFIER .)
    SEMICOLON       reduce using rule 29 (identifier -> PIDENTIFIER .)
    PLUS            reduce using rule 29 (identifier -> PIDENTIFIER .)
    MINUS           reduce using rule 29 (identifier -> PIDENTIFIER .)
    TIMES           reduce using rule 29 (identifier -> PIDENTIFIER .)
    DIVIDE          reduce using rule 29 (identifier -> PIDENTIFIER .)
    MODULO          reduce using rule 29 (identifier -> PIDENTIFIER .)
    THEN            reduce using rule 29 (identifier -> PIDENTIFIER .)
    DO              reduce using rule 29 (identifier -> PIDENTIFIER .)
    TO              reduce using rule 29 (identifier -> PIDENTIFIER .)
    DOWNTO          reduce using rule 29 (identifier -> PIDENTIFIER .)
    LBRACKET        shift and go to state 26


state 14

    (13) command -> READ . identifier SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    PIDENTIFIER     shift and go to state 13

    identifier                     shift and go to state 27

state 15

    (14) command -> WRITE . value SEMICOLON
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 28
    identifier                     shift and go to state 23

state 16

    (3) vdeclarations -> vdeclarations PIDENTIFIER LBRACKET . NUMBER RBRACKET

    NUMBER          shift and go to state 29


state 17

    (1) program -> VAR vdeclarations BEGIN commands END .

    $end            reduce using rule 1 (program -> VAR vdeclarations BEGIN commands END .)


state 18

    (5) commands -> commands command .

    END             reduce using rule 5 (commands -> commands command .)
    IF              reduce using rule 5 (commands -> commands command .)
    WHILE           reduce using rule 5 (commands -> commands command .)
    FOR             reduce using rule 5 (commands -> commands command .)
    READ            reduce using rule 5 (commands -> commands command .)
    WRITE           reduce using rule 5 (commands -> commands command .)
    PIDENTIFIER     reduce using rule 5 (commands -> commands command .)
    ELSE            reduce using rule 5 (commands -> commands command .)
    ENDIF           reduce using rule 5 (commands -> commands command .)
    ENDWHILE        reduce using rule 5 (commands -> commands command .)
    ENDFOR          reduce using rule 5 (commands -> commands command .)


state 19

    (7) command -> identifier ASSIGN . expression SEMICOLON
    (15) expression -> . value
    (16) expression -> . value PLUS value
    (17) expression -> . value MINUS value
    (18) expression -> . value TIMES value
    (19) expression -> . value DIVIDE value
    (20) expression -> . value MODULO value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    identifier                     shift and go to state 23
    expression                     shift and go to state 30
    value                          shift and go to state 31

state 20

    (8) command -> IF condition . THEN commands ELSE commands ENDIF
    (9) command -> IF condition . THEN commands ENDIF

    THEN            shift and go to state 32


state 21

    (21) condition -> value . EQ value
    (22) condition -> value . NE value
    (23) condition -> value . LT value
    (24) condition -> value . GT value
    (25) condition -> value . LE value
    (26) condition -> value . GE value

    EQ              shift and go to state 33
    NE              shift and go to state 34
    LT              shift and go to state 35
    GT              shift and go to state 36
    LE              shift and go to state 37
    GE              shift and go to state 38


state 22

    (27) value -> NUMBER .

    EQ              reduce using rule 27 (value -> NUMBER .)
    NE              reduce using rule 27 (value -> NUMBER .)
    LT              reduce using rule 27 (value -> NUMBER .)
    GT              reduce using rule 27 (value -> NUMBER .)
    LE              reduce using rule 27 (value -> NUMBER .)
    GE              reduce using rule 27 (value -> NUMBER .)
    SEMICOLON       reduce using rule 27 (value -> NUMBER .)
    PLUS            reduce using rule 27 (value -> NUMBER .)
    MINUS           reduce using rule 27 (value -> NUMBER .)
    TIMES           reduce using rule 27 (value -> NUMBER .)
    DIVIDE          reduce using rule 27 (value -> NUMBER .)
    MODULO          reduce using rule 27 (value -> NUMBER .)
    THEN            reduce using rule 27 (value -> NUMBER .)
    DO              reduce using rule 27 (value -> NUMBER .)
    TO              reduce using rule 27 (value -> NUMBER .)
    DOWNTO          reduce using rule 27 (value -> NUMBER .)


state 23

    (28) value -> identifier .

    EQ              reduce using rule 28 (value -> identifier .)
    NE              reduce using rule 28 (value -> identifier .)
    LT              reduce using rule 28 (value -> identifier .)
    GT              reduce using rule 28 (value -> identifier .)
    LE              reduce using rule 28 (value -> identifier .)
    GE              reduce using rule 28 (value -> identifier .)
    SEMICOLON       reduce using rule 28 (value -> identifier .)
    PLUS            reduce using rule 28 (value -> identifier .)
    MINUS           reduce using rule 28 (value -> identifier .)
    TIMES           reduce using rule 28 (value -> identifier .)
    DIVIDE          reduce using rule 28 (value -> identifier .)
    MODULO          reduce using rule 28 (value -> identifier .)
    THEN            reduce using rule 28 (value -> identifier .)
    DO              reduce using rule 28 (value -> identifier .)
    TO              reduce using rule 28 (value -> identifier .)
    DOWNTO          reduce using rule 28 (value -> identifier .)


state 24

    (10) command -> WHILE condition . DO commands ENDWHILE

    DO              shift and go to state 39


state 25

    (11) command -> FOR PIDENTIFIER . FROM value TO value DO commands ENDFOR
    (12) command -> FOR PIDENTIFIER . FROM value DOWNTO value DO commands ENDFOR

    FROM            shift and go to state 40


state 26

    (30) identifier -> PIDENTIFIER LBRACKET . PIDENTIFIER RBRACKET
    (31) identifier -> PIDENTIFIER LBRACKET . NUMBER RBRACKET

    PIDENTIFIER     shift and go to state 41
    NUMBER          shift and go to state 42


state 27

    (13) command -> READ identifier . SEMICOLON

    SEMICOLON       shift and go to state 43


state 28

    (14) command -> WRITE value . SEMICOLON

    SEMICOLON       shift and go to state 44


state 29

    (3) vdeclarations -> vdeclarations PIDENTIFIER LBRACKET NUMBER . RBRACKET

    RBRACKET        shift and go to state 45


state 30

    (7) command -> identifier ASSIGN expression . SEMICOLON

    SEMICOLON       shift and go to state 46


state 31

    (15) expression -> value .
    (16) expression -> value . PLUS value
    (17) expression -> value . MINUS value
    (18) expression -> value . TIMES value
    (19) expression -> value . DIVIDE value
    (20) expression -> value . MODULO value

    SEMICOLON       reduce using rule 15 (expression -> value .)
    PLUS            shift and go to state 47
    MINUS           shift and go to state 48
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50
    MODULO          shift and go to state 51


state 32

    (8) command -> IF condition THEN . commands ELSE commands ENDIF
    (9) command -> IF condition THEN . commands ENDIF
    (5) commands -> . commands command
    (6) commands -> . command
    (7) command -> . identifier ASSIGN expression SEMICOLON
    (8) command -> . IF condition THEN commands ELSE commands ENDIF
    (9) command -> . IF condition THEN commands ENDIF
    (10) command -> . WHILE condition DO commands ENDWHILE
    (11) command -> . FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> . FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
    (13) command -> . READ identifier SEMICOLON
    (14) command -> . WRITE value SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    READ            shift and go to state 14
    WRITE           shift and go to state 15
    PIDENTIFIER     shift and go to state 13

    commands                       shift and go to state 52
    command                        shift and go to state 8
    identifier                     shift and go to state 9

state 33

    (21) condition -> value EQ . value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 53
    identifier                     shift and go to state 23

state 34

    (22) condition -> value NE . value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 54
    identifier                     shift and go to state 23

state 35

    (23) condition -> value LT . value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 55
    identifier                     shift and go to state 23

state 36

    (24) condition -> value GT . value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 56
    identifier                     shift and go to state 23

state 37

    (25) condition -> value LE . value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 57
    identifier                     shift and go to state 23

state 38

    (26) condition -> value GE . value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 58
    identifier                     shift and go to state 23

state 39

    (10) command -> WHILE condition DO . commands ENDWHILE
    (5) commands -> . commands command
    (6) commands -> . command
    (7) command -> . identifier ASSIGN expression SEMICOLON
    (8) command -> . IF condition THEN commands ELSE commands ENDIF
    (9) command -> . IF condition THEN commands ENDIF
    (10) command -> . WHILE condition DO commands ENDWHILE
    (11) command -> . FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> . FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
    (13) command -> . READ identifier SEMICOLON
    (14) command -> . WRITE value SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    READ            shift and go to state 14
    WRITE           shift and go to state 15
    PIDENTIFIER     shift and go to state 13

    commands                       shift and go to state 59
    command                        shift and go to state 8
    identifier                     shift and go to state 9

state 40

    (11) command -> FOR PIDENTIFIER FROM . value TO value DO commands ENDFOR
    (12) command -> FOR PIDENTIFIER FROM . value DOWNTO value DO commands ENDFOR
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 60
    identifier                     shift and go to state 23

state 41

    (30) identifier -> PIDENTIFIER LBRACKET PIDENTIFIER . RBRACKET

    RBRACKET        shift and go to state 61


state 42

    (31) identifier -> PIDENTIFIER LBRACKET NUMBER . RBRACKET

    RBRACKET        shift and go to state 62


state 43

    (13) command -> READ identifier SEMICOLON .

    END             reduce using rule 13 (command -> READ identifier SEMICOLON .)
    IF              reduce using rule 13 (command -> READ identifier SEMICOLON .)
    WHILE           reduce using rule 13 (command -> READ identifier SEMICOLON .)
    FOR             reduce using rule 13 (command -> READ identifier SEMICOLON .)
    READ            reduce using rule 13 (command -> READ identifier SEMICOLON .)
    WRITE           reduce using rule 13 (command -> READ identifier SEMICOLON .)
    PIDENTIFIER     reduce using rule 13 (command -> READ identifier SEMICOLON .)
    ELSE            reduce using rule 13 (command -> READ identifier SEMICOLON .)
    ENDIF           reduce using rule 13 (command -> READ identifier SEMICOLON .)
    ENDWHILE        reduce using rule 13 (command -> READ identifier SEMICOLON .)
    ENDFOR          reduce using rule 13 (command -> READ identifier SEMICOLON .)


state 44

    (14) command -> WRITE value SEMICOLON .

    END             reduce using rule 14 (command -> WRITE value SEMICOLON .)
    IF              reduce using rule 14 (command -> WRITE value SEMICOLON .)
    WHILE           reduce using rule 14 (command -> WRITE value SEMICOLON .)
    FOR             reduce using rule 14 (command -> WRITE value SEMICOLON .)
    READ            reduce using rule 14 (command -> WRITE value SEMICOLON .)
    WRITE           reduce using rule 14 (command -> WRITE value SEMICOLON .)
    PIDENTIFIER     reduce using rule 14 (command -> WRITE value SEMICOLON .)
    ELSE            reduce using rule 14 (command -> WRITE value SEMICOLON .)
    ENDIF           reduce using rule 14 (command -> WRITE value SEMICOLON .)
    ENDWHILE        reduce using rule 14 (command -> WRITE value SEMICOLON .)
    ENDFOR          reduce using rule 14 (command -> WRITE value SEMICOLON .)


state 45

    (3) vdeclarations -> vdeclarations PIDENTIFIER LBRACKET NUMBER RBRACKET .

    BEGIN           reduce using rule 3 (vdeclarations -> vdeclarations PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    PIDENTIFIER     reduce using rule 3 (vdeclarations -> vdeclarations PIDENTIFIER LBRACKET NUMBER RBRACKET .)


state 46

    (7) command -> identifier ASSIGN expression SEMICOLON .

    END             reduce using rule 7 (command -> identifier ASSIGN expression SEMICOLON .)
    IF              reduce using rule 7 (command -> identifier ASSIGN expression SEMICOLON .)
    WHILE           reduce using rule 7 (command -> identifier ASSIGN expression SEMICOLON .)
    FOR             reduce using rule 7 (command -> identifier ASSIGN expression SEMICOLON .)
    READ            reduce using rule 7 (command -> identifier ASSIGN expression SEMICOLON .)
    WRITE           reduce using rule 7 (command -> identifier ASSIGN expression SEMICOLON .)
    PIDENTIFIER     reduce using rule 7 (command -> identifier ASSIGN expression SEMICOLON .)
    ELSE            reduce using rule 7 (command -> identifier ASSIGN expression SEMICOLON .)
    ENDIF           reduce using rule 7 (command -> identifier ASSIGN expression SEMICOLON .)
    ENDWHILE        reduce using rule 7 (command -> identifier ASSIGN expression SEMICOLON .)
    ENDFOR          reduce using rule 7 (command -> identifier ASSIGN expression SEMICOLON .)


state 47

    (16) expression -> value PLUS . value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 63
    identifier                     shift and go to state 23

state 48

    (17) expression -> value MINUS . value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 64
    identifier                     shift and go to state 23

state 49

    (18) expression -> value TIMES . value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 65
    identifier                     shift and go to state 23

state 50

    (19) expression -> value DIVIDE . value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 66
    identifier                     shift and go to state 23

state 51

    (20) expression -> value MODULO . value
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 67
    identifier                     shift and go to state 23

state 52

    (8) command -> IF condition THEN commands . ELSE commands ENDIF
    (9) command -> IF condition THEN commands . ENDIF
    (5) commands -> commands . command
    (7) command -> . identifier ASSIGN expression SEMICOLON
    (8) command -> . IF condition THEN commands ELSE commands ENDIF
    (9) command -> . IF condition THEN commands ENDIF
    (10) command -> . WHILE condition DO commands ENDWHILE
    (11) command -> . FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> . FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
    (13) command -> . READ identifier SEMICOLON
    (14) command -> . WRITE value SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    ELSE            shift and go to state 68
    ENDIF           shift and go to state 69
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    READ            shift and go to state 14
    WRITE           shift and go to state 15
    PIDENTIFIER     shift and go to state 13

    command                        shift and go to state 18
    identifier                     shift and go to state 9

state 53

    (21) condition -> value EQ value .

    THEN            reduce using rule 21 (condition -> value EQ value .)
    DO              reduce using rule 21 (condition -> value EQ value .)


state 54

    (22) condition -> value NE value .

    THEN            reduce using rule 22 (condition -> value NE value .)
    DO              reduce using rule 22 (condition -> value NE value .)


state 55

    (23) condition -> value LT value .

    THEN            reduce using rule 23 (condition -> value LT value .)
    DO              reduce using rule 23 (condition -> value LT value .)


state 56

    (24) condition -> value GT value .

    THEN            reduce using rule 24 (condition -> value GT value .)
    DO              reduce using rule 24 (condition -> value GT value .)


state 57

    (25) condition -> value LE value .

    THEN            reduce using rule 25 (condition -> value LE value .)
    DO              reduce using rule 25 (condition -> value LE value .)


state 58

    (26) condition -> value GE value .

    THEN            reduce using rule 26 (condition -> value GE value .)
    DO              reduce using rule 26 (condition -> value GE value .)


state 59

    (10) command -> WHILE condition DO commands . ENDWHILE
    (5) commands -> commands . command
    (7) command -> . identifier ASSIGN expression SEMICOLON
    (8) command -> . IF condition THEN commands ELSE commands ENDIF
    (9) command -> . IF condition THEN commands ENDIF
    (10) command -> . WHILE condition DO commands ENDWHILE
    (11) command -> . FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> . FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
    (13) command -> . READ identifier SEMICOLON
    (14) command -> . WRITE value SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    ENDWHILE        shift and go to state 70
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    READ            shift and go to state 14
    WRITE           shift and go to state 15
    PIDENTIFIER     shift and go to state 13

    command                        shift and go to state 18
    identifier                     shift and go to state 9

state 60

    (11) command -> FOR PIDENTIFIER FROM value . TO value DO commands ENDFOR
    (12) command -> FOR PIDENTIFIER FROM value . DOWNTO value DO commands ENDFOR

    TO              shift and go to state 71
    DOWNTO          shift and go to state 72


state 61

    (30) identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .

    ASSIGN          reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    EQ              reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    NE              reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    LT              reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    GT              reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    LE              reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    GE              reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    SEMICOLON       reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    PLUS            reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    MINUS           reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    TIMES           reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    DIVIDE          reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    MODULO          reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    THEN            reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    DO              reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    TO              reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)
    DOWNTO          reduce using rule 30 (identifier -> PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET .)


state 62

    (31) identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .

    ASSIGN          reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    EQ              reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    NE              reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    LT              reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    GT              reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    LE              reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    GE              reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    SEMICOLON       reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    PLUS            reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    MINUS           reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    TIMES           reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    DIVIDE          reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    MODULO          reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    THEN            reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    DO              reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    TO              reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)
    DOWNTO          reduce using rule 31 (identifier -> PIDENTIFIER LBRACKET NUMBER RBRACKET .)


state 63

    (16) expression -> value PLUS value .

    SEMICOLON       reduce using rule 16 (expression -> value PLUS value .)


state 64

    (17) expression -> value MINUS value .

    SEMICOLON       reduce using rule 17 (expression -> value MINUS value .)


state 65

    (18) expression -> value TIMES value .

    SEMICOLON       reduce using rule 18 (expression -> value TIMES value .)


state 66

    (19) expression -> value DIVIDE value .

    SEMICOLON       reduce using rule 19 (expression -> value DIVIDE value .)


state 67

    (20) expression -> value MODULO value .

    SEMICOLON       reduce using rule 20 (expression -> value MODULO value .)


state 68

    (8) command -> IF condition THEN commands ELSE . commands ENDIF
    (5) commands -> . commands command
    (6) commands -> . command
    (7) command -> . identifier ASSIGN expression SEMICOLON
    (8) command -> . IF condition THEN commands ELSE commands ENDIF
    (9) command -> . IF condition THEN commands ENDIF
    (10) command -> . WHILE condition DO commands ENDWHILE
    (11) command -> . FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> . FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
    (13) command -> . READ identifier SEMICOLON
    (14) command -> . WRITE value SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    READ            shift and go to state 14
    WRITE           shift and go to state 15
    PIDENTIFIER     shift and go to state 13

    commands                       shift and go to state 73
    command                        shift and go to state 8
    identifier                     shift and go to state 9

state 69

    (9) command -> IF condition THEN commands ENDIF .

    END             reduce using rule 9 (command -> IF condition THEN commands ENDIF .)
    IF              reduce using rule 9 (command -> IF condition THEN commands ENDIF .)
    WHILE           reduce using rule 9 (command -> IF condition THEN commands ENDIF .)
    FOR             reduce using rule 9 (command -> IF condition THEN commands ENDIF .)
    READ            reduce using rule 9 (command -> IF condition THEN commands ENDIF .)
    WRITE           reduce using rule 9 (command -> IF condition THEN commands ENDIF .)
    PIDENTIFIER     reduce using rule 9 (command -> IF condition THEN commands ENDIF .)
    ELSE            reduce using rule 9 (command -> IF condition THEN commands ENDIF .)
    ENDIF           reduce using rule 9 (command -> IF condition THEN commands ENDIF .)
    ENDWHILE        reduce using rule 9 (command -> IF condition THEN commands ENDIF .)
    ENDFOR          reduce using rule 9 (command -> IF condition THEN commands ENDIF .)


state 70

    (10) command -> WHILE condition DO commands ENDWHILE .

    END             reduce using rule 10 (command -> WHILE condition DO commands ENDWHILE .)
    IF              reduce using rule 10 (command -> WHILE condition DO commands ENDWHILE .)
    WHILE           reduce using rule 10 (command -> WHILE condition DO commands ENDWHILE .)
    FOR             reduce using rule 10 (command -> WHILE condition DO commands ENDWHILE .)
    READ            reduce using rule 10 (command -> WHILE condition DO commands ENDWHILE .)
    WRITE           reduce using rule 10 (command -> WHILE condition DO commands ENDWHILE .)
    PIDENTIFIER     reduce using rule 10 (command -> WHILE condition DO commands ENDWHILE .)
    ELSE            reduce using rule 10 (command -> WHILE condition DO commands ENDWHILE .)
    ENDIF           reduce using rule 10 (command -> WHILE condition DO commands ENDWHILE .)
    ENDWHILE        reduce using rule 10 (command -> WHILE condition DO commands ENDWHILE .)
    ENDFOR          reduce using rule 10 (command -> WHILE condition DO commands ENDWHILE .)


state 71

    (11) command -> FOR PIDENTIFIER FROM value TO . value DO commands ENDFOR
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 74
    identifier                     shift and go to state 23

state 72

    (12) command -> FOR PIDENTIFIER FROM value DOWNTO . value DO commands ENDFOR
    (27) value -> . NUMBER
    (28) value -> . identifier
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    NUMBER          shift and go to state 22
    PIDENTIFIER     shift and go to state 13

    value                          shift and go to state 75
    identifier                     shift and go to state 23

state 73

    (8) command -> IF condition THEN commands ELSE commands . ENDIF
    (5) commands -> commands . command
    (7) command -> . identifier ASSIGN expression SEMICOLON
    (8) command -> . IF condition THEN commands ELSE commands ENDIF
    (9) command -> . IF condition THEN commands ENDIF
    (10) command -> . WHILE condition DO commands ENDWHILE
    (11) command -> . FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> . FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
    (13) command -> . READ identifier SEMICOLON
    (14) command -> . WRITE value SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    ENDIF           shift and go to state 76
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    READ            shift and go to state 14
    WRITE           shift and go to state 15
    PIDENTIFIER     shift and go to state 13

    command                        shift and go to state 18
    identifier                     shift and go to state 9

state 74

    (11) command -> FOR PIDENTIFIER FROM value TO value . DO commands ENDFOR

    DO              shift and go to state 77


state 75

    (12) command -> FOR PIDENTIFIER FROM value DOWNTO value . DO commands ENDFOR

    DO              shift and go to state 78


state 76

    (8) command -> IF condition THEN commands ELSE commands ENDIF .

    END             reduce using rule 8 (command -> IF condition THEN commands ELSE commands ENDIF .)
    IF              reduce using rule 8 (command -> IF condition THEN commands ELSE commands ENDIF .)
    WHILE           reduce using rule 8 (command -> IF condition THEN commands ELSE commands ENDIF .)
    FOR             reduce using rule 8 (command -> IF condition THEN commands ELSE commands ENDIF .)
    READ            reduce using rule 8 (command -> IF condition THEN commands ELSE commands ENDIF .)
    WRITE           reduce using rule 8 (command -> IF condition THEN commands ELSE commands ENDIF .)
    PIDENTIFIER     reduce using rule 8 (command -> IF condition THEN commands ELSE commands ENDIF .)
    ELSE            reduce using rule 8 (command -> IF condition THEN commands ELSE commands ENDIF .)
    ENDIF           reduce using rule 8 (command -> IF condition THEN commands ELSE commands ENDIF .)
    ENDWHILE        reduce using rule 8 (command -> IF condition THEN commands ELSE commands ENDIF .)
    ENDFOR          reduce using rule 8 (command -> IF condition THEN commands ELSE commands ENDIF .)


state 77

    (11) command -> FOR PIDENTIFIER FROM value TO value DO . commands ENDFOR
    (5) commands -> . commands command
    (6) commands -> . command
    (7) command -> . identifier ASSIGN expression SEMICOLON
    (8) command -> . IF condition THEN commands ELSE commands ENDIF
    (9) command -> . IF condition THEN commands ENDIF
    (10) command -> . WHILE condition DO commands ENDWHILE
    (11) command -> . FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> . FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
    (13) command -> . READ identifier SEMICOLON
    (14) command -> . WRITE value SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    READ            shift and go to state 14
    WRITE           shift and go to state 15
    PIDENTIFIER     shift and go to state 13

    commands                       shift and go to state 79
    command                        shift and go to state 8
    identifier                     shift and go to state 9

state 78

    (12) command -> FOR PIDENTIFIER FROM value DOWNTO value DO . commands ENDFOR
    (5) commands -> . commands command
    (6) commands -> . command
    (7) command -> . identifier ASSIGN expression SEMICOLON
    (8) command -> . IF condition THEN commands ELSE commands ENDIF
    (9) command -> . IF condition THEN commands ENDIF
    (10) command -> . WHILE condition DO commands ENDWHILE
    (11) command -> . FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> . FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
    (13) command -> . READ identifier SEMICOLON
    (14) command -> . WRITE value SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    READ            shift and go to state 14
    WRITE           shift and go to state 15
    PIDENTIFIER     shift and go to state 13

    commands                       shift and go to state 80
    command                        shift and go to state 8
    identifier                     shift and go to state 9

state 79

    (11) command -> FOR PIDENTIFIER FROM value TO value DO commands . ENDFOR
    (5) commands -> commands . command
    (7) command -> . identifier ASSIGN expression SEMICOLON
    (8) command -> . IF condition THEN commands ELSE commands ENDIF
    (9) command -> . IF condition THEN commands ENDIF
    (10) command -> . WHILE condition DO commands ENDWHILE
    (11) command -> . FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> . FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
    (13) command -> . READ identifier SEMICOLON
    (14) command -> . WRITE value SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    ENDFOR          shift and go to state 81
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    READ            shift and go to state 14
    WRITE           shift and go to state 15
    PIDENTIFIER     shift and go to state 13

    command                        shift and go to state 18
    identifier                     shift and go to state 9

state 80

    (12) command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands . ENDFOR
    (5) commands -> commands . command
    (7) command -> . identifier ASSIGN expression SEMICOLON
    (8) command -> . IF condition THEN commands ELSE commands ENDIF
    (9) command -> . IF condition THEN commands ENDIF
    (10) command -> . WHILE condition DO commands ENDWHILE
    (11) command -> . FOR PIDENTIFIER FROM value TO value DO commands ENDFOR
    (12) command -> . FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR
    (13) command -> . READ identifier SEMICOLON
    (14) command -> . WRITE value SEMICOLON
    (29) identifier -> . PIDENTIFIER
    (30) identifier -> . PIDENTIFIER LBRACKET PIDENTIFIER RBRACKET
    (31) identifier -> . PIDENTIFIER LBRACKET NUMBER RBRACKET

    ENDFOR          shift and go to state 82
    IF              shift and go to state 10
    WHILE           shift and go to state 11
    FOR             shift and go to state 12
    READ            shift and go to state 14
    WRITE           shift and go to state 15
    PIDENTIFIER     shift and go to state 13

    command                        shift and go to state 18
    identifier                     shift and go to state 9

state 81

    (11) command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR .

    END             reduce using rule 11 (command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR .)
    IF              reduce using rule 11 (command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR .)
    WHILE           reduce using rule 11 (command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR .)
    FOR             reduce using rule 11 (command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR .)
    READ            reduce using rule 11 (command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR .)
    WRITE           reduce using rule 11 (command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR .)
    PIDENTIFIER     reduce using rule 11 (command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR .)
    ELSE            reduce using rule 11 (command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR .)
    ENDIF           reduce using rule 11 (command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR .)
    ENDWHILE        reduce using rule 11 (command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR .)
    ENDFOR          reduce using rule 11 (command -> FOR PIDENTIFIER FROM value TO value DO commands ENDFOR .)


state 82

    (12) command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR .

    END             reduce using rule 12 (command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR .)
    IF              reduce using rule 12 (command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR .)
    WHILE           reduce using rule 12 (command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR .)
    FOR             reduce using rule 12 (command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR .)
    READ            reduce using rule 12 (command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR .)
    WRITE           reduce using rule 12 (command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR .)
    PIDENTIFIER     reduce using rule 12 (command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR .)
    ELSE            reduce using rule 12 (command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR .)
    ENDIF           reduce using rule 12 (command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR .)
    ENDWHILE        reduce using rule 12 (command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR .)
    ENDFOR          reduce using rule 12 (command -> FOR PIDENTIFIER FROM value DOWNTO value DO commands ENDFOR .)

