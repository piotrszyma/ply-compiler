diff --git a/lib/machine.py b/lib/machine.py
index 10eaf6f..9944434 100644
--- a/lib/machine.py
+++ b/lib/machine.py
@@ -1,6 +1,3 @@
-import re
-from collections import Counter
-
 from lib.error import CompilerError
 from lib.utils import is_int, is_number, is_operation, is_inttab, is_label, is_variable, symtab_sort
 
@@ -37,11 +34,22 @@ class Machine:
     def reserve_memory(self, symtab):
         for i in range(10):
             self.mem[i] = str(i)
+        mem_addr = 10
+
+        for symbol in symtab_sort(symtab):
+            if symbol[0] != '#' and '#' in symbol:
+                symbol, size = symbol.split('#')
+                size = int(size)
+                self.mem[symbol + '#0'] = {
+                    'address': mem_addr,
+                    'size':    size
+                }
+                mem_addr += size
+            else:
+                self.mem[symbol] = mem_addr
+                mem_addr += 1
 
-        for index, symbol in enumerate(symtab_sort(symtab), 10):
-            self.mem[symbol] = index
-
-        self.free_index = 10 + len(symtab)
+        self.free_index = mem_addr
 
     def set_labels(self, flow):
         for c in flow:
@@ -70,15 +78,7 @@ class Machine:
                 resolved[i] = '{} {}'.format(c[0], labels[c[1]])
         self.code = resolved
 
-    def generate_number(self, number, add=True):
-        # code = []
-
-        mem_addr = '#{}'.format(number)
-        # mem_val = self.mem.get(mem_addr, False)
-        #
-        # if mem_val:
-        #     code += ['LOAD {}'.format(mem_val)]
-        # else:
+    def generate_number(self, number):
         code = ['ZERO']
 
         if number != 0:
@@ -89,12 +89,6 @@ class Machine:
                 if d == '1':
                     code += ['INC']
 
-        # self.mem[mem_addr] = self.free_index
-        # code += ['STORE {}'.format(self.free_index)]
-        #
-        # self.free_index += 1
-        if add:
-            self.code += code
         return "\n".join(code)
 
     def assign(self, target, expression):
@@ -117,11 +111,11 @@ class Machine:
         self.parse(code, a=source, b=target)
 
     def assign_number(self, target, source):
-        self.generate_number(source)
         code = """
+        GENERATE n
         STORE b
         """
-        self.parse(code, b=target)
+        self.parse(code, n=source, b=target)
 
     def assign_operation(self, target, equation):
         sign, *operands = equation
@@ -140,7 +134,7 @@ class Machine:
         x, y = operands
         if is_number(x):
             if is_number(y):
-                self.parse('GENERATE n', n=x+y)
+                self.parse('GENERATE n', n=x + y)
             else:
                 x, y = y, x
 
@@ -373,7 +367,7 @@ class Machine:
         self.parse(code, a=source)
 
     def write_number(self, value):
-        self.generate_number(value)
+        self.parse('GENERATE n', n=value)
         self.parse('PUT')
 
     def read(self, target):
@@ -413,6 +407,10 @@ class Machine:
         if is_number(right):
             right, left = left, right
 
+        if left == right:
+            self.parse('JUMP @label', label=label)
+            return
+
         if is_number(left) and left == 0:
             code = """
             LOAD a
@@ -421,10 +419,6 @@ class Machine:
             self.parse(code, a=right, label=label)
             return
 
-        if left == right:
-            self.parse('JUMP @label', label=label)
-            return
-
         if is_number(left):
             code += """
             GENERATE l_val
@@ -459,6 +453,27 @@ class Machine:
 
     def comp_neq(self, cond, label):
         left, _, right = cond
+
+        if is_number(left) and is_number(right):
+            if left == right:
+                return
+            else:
+                self.parse('JUMP @label', label=label)
+                return
+
+        if is_number(right):
+            right, left = left, right
+
+        if not is_number(right) and is_number(left) and left == 0:
+            code = """
+            LOAD a
+            JZERO #FALSE
+            JUMP @label
+            #FALSE:
+            """
+            self.parse(code, a=right, label=label)
+            return
+
         code = ""
 
         if is_number(left):
@@ -528,6 +543,11 @@ class Machine:
 
     def comp_geq(self, cond, label):
         left, _, right = cond
+
+        if is_number(right) and right == 0:
+            self.parse("JUMP @label", label=label)
+            return
+
         code = ""
         if is_number(left):
             code += """
@@ -559,10 +579,12 @@ class Machine:
                    )
 
     def comp_lt(self, cond, label):
-        self.comp_gt((cond[2], '>', cond[0]), label)
+        left, _, right = cond
+        self.comp_gt((right, '>', left), label)
 
     def comp_leq(self, cond, label):
-        self.comp_geq((cond[2], '<=', cond[0]), label)
+        left, _, right = cond
+        self.comp_geq((right, '<=', left), label)
 
     def parse(self, code, **variables):
         """
@@ -575,7 +597,7 @@ class Machine:
             left, right = (c.split(" ") + [None])[:2]
             if left == 'GENERATE':
                 number = int(variables[right])
-                cmds = self.generate_number(number, False).split('\n')
+                cmds = self.generate_number(number).split('\n')
                 self.code.extend(cmds)
             elif not right and left[1:-1] not in labels.keys() and left[0] == '#':
                 # for new labels, generate unique labels names
@@ -617,14 +639,17 @@ class Machine:
     def parse_array(self, left, right):
         _, var, index, *_ = right
         if is_number(index):
-            addr = '{}#{}'.format(var, index)
+            array = self.mem['{}#0'.format(var)]
+            arr_addr = array['address']
+            cell_addr = index + arr_addr
             code = '{cmd} {param}'.format(
                 cmd=left,
-                param=self.mem[addr])
+                param=cell_addr)
             self.code.append(code)
         elif is_variable(index):
             left += 'I'
-            arr_addr = self.mem['{}#0'.format(var)]
+            array = self.mem['{}#0'.format(var)]
+            arr_addr = array['address']
             if left == 'LOADI':
                 code = """
                 GENERATE num
@@ -648,4 +673,3 @@ class Machine:
 
     def end(self):
         self.parse('HALT')
-
diff --git a/lib/optimization.py b/lib/optimization.py
index e73a26a..5fb6c59 100644
--- a/lib/optimization.py
+++ b/lib/optimization.py
@@ -1,9 +1,18 @@
 class Optimization:
+    __slots__ = {
+        'cmds'
+    }
+
+    def __init__(self):
+        self.cmds = []
+
     def optimize(self, cmds):
-        cmds = self.opt_remove_store_load(cmds)
-        return cmds
+        self.cmds = cmds
+        # self.opt_remove_store_load()
+        # self.opt_halt_if_no_write()
+        return self.cmds
 
-    def opt_remove_store_load(self, cmds):
+    def opt_remove_store_load(self):
         """
         STORE x
         LOAD x
@@ -12,6 +21,7 @@ class Optimization:
 
         STORE x
         """
+        cmds = self.cmds
 
         for index, cmd in enumerate(cmds[:-1]):
             u_i = index
@@ -24,6 +34,10 @@ class Optimization:
                 if u_cmd == 'STORE' and l_cmd == 'LOAD' and u_addr == l_addr:
                     cmds[l_i] = 'DELETE'
 
-        cmds = filter(lambda x: x != 'DELETE', cmds)
+        self.cmds = list(filter(lambda x: x != 'DELETE', cmds))
 
-        return cmds
+    def opt_halt_if_no_write(self):
+        reads = self.cmds.count('GET')
+        writes = self.cmds.count('PUT')
+        if writes == 0:
+            self.cmds = ['GET' * reads] if reads > 0 else [] + ['HALT']
diff --git a/lib/static_analysis.py b/lib/static_analysis.py
index 8267f50..ea599d1 100644
--- a/lib/static_analysis.py
+++ b/lib/static_analysis.py
@@ -9,7 +9,8 @@ class StaticAnalyzer:
         'scope',
         'symbols',
         'initialized',
-        'iterators'
+        'iterators',
+        'arrays'
     }
 
     def __init__(self):
@@ -17,6 +18,7 @@ class StaticAnalyzer:
         self.scope = set()
         self.initialized = {}
         self.iterators = set()
+        self.arrays = {}
 
     def add_iterator(self, var):
         self.iterators.add(var)
@@ -38,10 +40,15 @@ class StaticAnalyzer:
         else:
             commands = parse_tree
         self.check_commands(commands)
-        return self.symbols, commands
+
+        parsed_symbols = [s[:-2] + '#' + str(self.arrays[s]) if s[-2:] == '#0' else s for s in self.symbols]
+
+        return parsed_symbols, commands
 
     def check_for_duplicate_declarations(self, declarations):
         seen = []
+        arrays = {}
+
         for kind, val, *details, lineno in declarations:
             if val in seen:
                 raise_error(
@@ -50,11 +57,18 @@ class StaticAnalyzer:
                 )
             if kind == 'int[]':
                 [size] = details
-                seen.extend([val + '#' + str(i) for i in range(size)])
+                seen.append(val + '#0')
+                if val in arrays.keys():
+                    raise_error(
+                        msg='double declaration of array {}'.format(val),
+                        lineno=lineno
+                    )
+                arrays[val + '#0'] = size
             else:
                 seen.append(val)
         self.symbols = set(seen)
         self.scope = set(seen)
+        self.arrays = arrays
 
     def check_commands(self, cmds):
         for c in cmds:
@@ -99,15 +113,8 @@ class StaticAnalyzer:
             if not self.initialized.get(symbol, False):
                 raise_error("Usage of uninitialized variable '{symbol}'".format(symbol=symbol), lineno)
         elif is_inttab(var):
+            # Cannot check int tab initialization
             pass
-            # TODO: check if it works?
-            # _, symbol, index, lineno = var
-            # if not is_number(index):
-            #     return
-            # symbol = '#'.join([symbol, str(index)])
-            # if not self.initialized.get(symbol, False):
-            #     import pdb; pdb.set_trace()
-            #     raise_error("Usage of uninitialized array element '{symbol}'".format(symbol=symbol), lineno)
 
     def check_write(self, cmd):
         _, operand = cmd
@@ -116,7 +123,6 @@ class StaticAnalyzer:
             self.check_initialized(operand)
 
     def check_read(self, cmd):
-        # import pdb; pdb.set_trace()
         _, operand = cmd
         self.check_variable(operand)
         _, symbol, *_ = operand
@@ -193,14 +199,17 @@ class StaticAnalyzer:
             raise_error("Usage of undeclared array {}".format(symbol), lineno)
 
         if is_number(index):
-            el_symbol = '#'.join([symbol, str(index)])
-            if el_symbol not in self.scope:
-                raise_error("Array index out of scope".format(symbol), lineno)
+            self.check_inttab_index(variable)
         elif is_int(index):
             self.check_variable(index)
         else:
             raise CompilerError("Unexpected array index")
 
+    def check_inttab_index(self, variable):
+        _, symbol, index, lineno = variable
+        if not 0 <= index <= self.arrays[symbol + '#0'] - 1:
+            raise_error("Array {} index out of range".format(symbol), lineno)
+
     def check_int(self, variable):
         _, symbol, lineno = variable
         if '#'.join([symbol, '0']) in self.scope:
@@ -225,21 +234,6 @@ class StaticAnalyzer:
                 )
         elif is_inttab(operand):
             if is_number(operand[2]):
-                arr_start = '{arr_name}#{index}'.format(
-                    arr_name=operand[1],
-                    index=0
-                )
-                name = '{arr_name}#{index}'.format(
-                    arr_name=operand[1],
-                    index=operand[2]
-                )
-                if arr_start not in self.scope:
-                    if operand[1] in self.scope:
-                        raise_error("Trying to assign to array '{}' without specifing index".format(operand[1]))
-                    raise_error("Undeclared array {}".format(operand[1]))
-                if name not in self.scope:
-                    raise_error(
-                        msg="Array index out of range {}".format(operand[1])
-                    )
+                self.check_inttab_index(operand)
         else:
             raise CompilerError("Unexpected operand")
diff --git a/program0.imp b/program0.imp
index a90b90a..171617a 100644
--- a/program0.imp
+++ b/program0.imp
@@ -1,21 +1,7 @@
-( program5.imp )
-VAR
-  tab[999999999] a b c d n 
+VAR 
+    a b
 BEGIN
-  READ a;
-  tab[a] := 9;
-
-  n := 999999998;
-  tab[n] := tab[a];
-  
-  b :=  111111111;
-  b := b * tab[a];
-  
-  c :=  90909090;
-  READ d;
-  
-  tab[a] := b - c;
-  tab[n] := tab[a] / d;
-  WRITE tab[a];
-  WRITE tab[n];
-END 
+    IF 0 <> 0 THEN WRITE 1; ENDIF
+    a := 3;
+    WRITE a;
+END
\ No newline at end of file
diff --git a/test/functionality/test_comparison.py b/test/functionality/test_comparison.py
index c7c7115..3e71a1e 100644
--- a/test/functionality/test_comparison.py
+++ b/test/functionality/test_comparison.py
@@ -57,6 +57,38 @@ class TestComparisons(CompilerTestCase):
             '2\n3'
         )
 
+        self.assertOutputEquals(
+            NEW_MIX,
+            ''
+        )
+
+
+NEW_MIX = """
+VAR 
+    a b
+BEGIN
+    IF 0 < 0 THEN WRITE 1; ENDIF
+    IF 1 < 0 THEN WRITE 1; ENDIF
+    IF 123 < 0 THEN WRITE 1; ENDIF
+       
+    IF 0 > 0 THEN WRITE 1; ENDIF
+    IF 110 > 111 THEN WRITE 1; ENDIF
+    
+    IF 0 >= 1 THEN WRITE 1; ENDIF
+    IF 0 >= 1123 THEN WRITE 1; ENDIF
+    IF 123 >= 1123 THEN WRITE 1; ENDIF
+    IF 1122 >= 1123 THEN WRITE 1; ENDIF
+    IF 1122 >= 1124 THEN WRITE 1; ENDIF
+    
+    IF 1125 <= 1124 THEN WRITE 1; ENDIF
+    IF 1 <= 0 THEN WRITE 1; ENDIF
+    IF 2 <= 0 THEN WRITE 1; ENDIF
+    
+    IF 2 = 0 THEN WRITE 1; ENDIF
+    IF 0 <> 0 THEN WRITE 1; ENDIF
+END
+
+"""
 
 ALTB = """
 VAR
diff --git a/test/gotfryd/new/program5.imp b/test/gotfryd/new/program5.imp
index a90b90a..7e473c2 100755
--- a/test/gotfryd/new/program5.imp
+++ b/test/gotfryd/new/program5.imp
@@ -7,13 +7,13 @@ BEGIN
 
   n := 999999998;
   tab[n] := tab[a];
-  
+
   b :=  111111111;
   b := b * tab[a];
-  
+
   c :=  90909090;
   READ d;
-  
+
   tab[a] := b - c;
   tab[n] := tab[a] / d;
   WRITE tab[a];
